["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$clojure.test.check","~:imports",null,"~:requires",["^ ","~$clojure.test.check.results","^9","~$rose","~$clojure.test.check.rose-tree","~$results","^9","~$clojure.test.check.impl","^=","^;","^;","~$clojure.test.check.generators","^>","~$gen","^>","~$clojure.test.check.random","^@","~$random","^@"],"~:cljs.spec/speced-vars",[],"~:uses",["^ ","~$get-current-time-millis","^="],"~:defs",["^ ","~$shrink-loop",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/jb/Google-Drive/Planung/Clojure-Script/dep-reframe/target/public/cljs-out/dep/clojure/test/check.cljc","~:line",242,"~:column",8,"~:end-line",242,"~:end-column",19,"~:private",true,"~:arglists",["~#list",["~$quote",["^P",[["~$rose-tree","~$reporter-fn"]]]]],"~:doc","Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found.\n\n  Calls reporter-fn on every shrink step."],"^N",true,"^5","~$clojure.test.check/shrink-loop","^I","target/public/cljs-out/dep/clojure/test/check.cljc","^M",19,"~:method-params",["^P",[["^R","^S"]]],"~:protocol-impl",null,"~:arglists-meta",["^P",[null,null]],"^K",1,"~:variadic?",false,"^J",242,"~:ret-tag","~$cljs.core/IMap","^L",242,"~:max-fixed-arity",2,"~:fn-var",true,"^O",["^P",["^Q",["^P",[["^R","^S"]]]]],"^T","Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found.\n\n  Calls reporter-fn on every shrink step."],"~$failure",["^ ","^G",null,"^H",["^ ","^I","/Users/jb/Google-Drive/Planung/Clojure-Script/dep-reframe/target/public/cljs-out/dep/clojure/test/check.cljc","^J",297,"^K",8,"^L",297,"^M",15,"^N",true,"^O",["^P",["^Q",["^P",[["~$property","~$failing-rose-tree","~$trial-number","~$size","~$seed","~$start-time","^S"]]]]]],"^N",true,"^5","~$clojure.test.check/failure","^I","target/public/cljs-out/dep/clojure/test/check.cljc","^M",15,"^V",["^P",[["^13","^14","^15","^16","^17","^18","^S"]]],"^W",null,"^X",["^P",[null,null]],"^K",1,"^Y",false,"^J",297,"^Z",["^4",["~$clj","~$any"]],"^L",297,"^10",7,"^11",true,"^O",["^P",["^Q",["^P",[["^13","^14","^15","^16","^17","^18","^S"]]]]]],"~$make-rng",["^ ","^G",null,"^H",["^ ","^I","/Users/jb/Google-Drive/Planung/Clojure-Script/dep-reframe/target/public/cljs-out/dep/clojure/test/check.cljc","^J",19,"^K",8,"^L",19,"^M",16,"^N",true,"^O",["^P",["^Q",["^P",[["^17"]]]]]],"^N",true,"^5","~$clojure.test.check/make-rng","^I","target/public/cljs-out/dep/clojure/test/check.cljc","^M",16,"^V",["^P",[["^17"]]],"^W",null,"^X",["^P",[null,null]],"^K",1,"^Y",false,"^J",19,"^Z","~$cljs.core/IVector","^L",19,"^10",1,"^11",true,"^O",["^P",["^Q",["^P",[["^17"]]]]]],"~$complete",["^ ","^G",null,"^H",["^ ","^I","/Users/jb/Google-Drive/Planung/Clojure-Script/dep-reframe/target/public/cljs-out/dep/clojure/test/check.cljc","^J",26,"^K",8,"^L",26,"^M",16,"^N",true,"^O",["^P",["^Q",["^P",[["^13","~$num-trials","^17","^18","^S"]]]]]],"^N",true,"^5","~$clojure.test.check/complete","^I","target/public/cljs-out/dep/clojure/test/check.cljc","^M",16,"^V",["^P",[["^13","^1@","^17","^18","^S"]]],"^W",null,"^X",["^P",[null,null]],"^K",1,"^Y",false,"^J",26,"^Z","^[","^L",26,"^10",5,"^11",true,"^O",["^P",["^Q",["^P",[["^13","^1@","^17","^18","^S"]]]]]],"~$legacy-result",["^ ","^G",null,"^H",["^ ","^I","/Users/jb/Google-Drive/Planung/Clojure-Script/dep-reframe/target/public/cljs-out/dep/clojure/test/check.cljc","^J",43,"^K",17,"^L",43,"^M",30,"^N",true,"^O",["^P",["^Q",["^P",[["~$result"]]]]],"^T","Returns a value for the legacy :result key, which has the peculiar\n  property of conflating returned exceptions with thrown exceptions."],"^N",true,"^5","~$clojure.test.check/legacy-result","^I","target/public/cljs-out/dep/clojure/test/check.cljc","^M",30,"^V",["^P",[["^1C"]]],"^W",null,"^X",["^P",[null,null]],"^K",1,"^Y",false,"^J",43,"^Z",["^4",[null,"^1;","~$cljs.core/ExceptionInfo","~$clj-nil"]],"^L",43,"^10",1,"^11",true,"^O",["^P",["^Q",["^P",[["^1C"]]]]],"^T","Returns a value for the legacy :result key, which has the peculiar\n  property of conflating returned exceptions with thrown exceptions."],"~$quick-check",["^ ","^G",null,"^H",["^ ","^I","/Users/jb/Google-Drive/Planung/Clojure-Script/dep-reframe/target/public/cljs-out/dep/clojure/test/check.cljc","^J",59,"^K",7,"^L",59,"^M",18,"^O",["^P",["^Q",["^P",[["~$num-tests","^13","~$&",["^ ","~:keys",["^17","~$max-size","^S"],"~:or",["^ ","^1J",200,"^S",["^P",["~$constantly",null]]]]]]]]],"^T","Tests `property` `num-tests` times.\n\n  Takes several optional keys:\n\n  `:seed`\n    Can be used to re-run previous tests, as the seed used is returned\n    after a test is run.\n\n  `:max-size`.\n    can be used to control the 'size' of generated values. The size will\n    start at 0, and grow up to max-size, as the number of tests increases.\n    Generators will use the size parameter to bound their growth. This\n    prevents, for example, generating a five-thousand element vector on\n    the very first test.\n\n  `:reporter-fn`\n    A callback function that will be called at various points in the test\n    run, with a map like:\n\n      ;; called after a passing trial\n      {:type            :trial\n       :args            [...]\n       :num-tests       <number of tests run so far>\n       :num-tests-total <total number of tests to be run>\n       :seed            42\n       :pass?           true\n       :property        #<...>\n       :result          true\n       :result-data     {...}}\n\n      ;; called after the first failing trial\n      {:type         :failure\n       :fail         [...failing args...]\n       :failing-size 13\n       :num-tests    <tests ran before failure found>\n       :pass?        false\n       :property     #<...>\n       :result       false/exception\n       :result-data  {...}\n       :seed         42}\n\n    It will also be called on :complete, :shrink-step and :shrunk. Many\n    of the keys also appear in the quick-check return value, and are\n    documented below.\n\n  If the test passes, the return value will be something like:\n\n      {:num-tests       100,\n       :pass?           true,\n       :result          true,\n       :seed            1561826505982,\n       :time-elapsed-ms 24}\n\n  If the test fails, the return value will be something like:\n\n      {:fail            [0],\n       :failed-after-ms 0,\n       :failing-size    0,\n       :num-tests       1,\n       :pass?           false,\n       :result          false,\n       :result-data     nil,\n       :seed            1561826506080,\n       :shrunk\n       {:depth               0,\n        :pass?               false,\n        :result              false,\n        :result-data         nil,\n        :smallest            [0],\n        :time-shrinking-ms   0,\n        :total-nodes-visited 0}}\n\n  The meaning of the individual entries is:\n\n      :num-tests\n      The total number of trials that was were run, not including\n      shrinking (if applicable)\n\n      :pass?\n      A boolean indicating whether the test passed or failed\n\n      :result\n      A legacy entry that is similar to :pass?\n\n      :seed\n      The seed used for the entire test run; can be used to reproduce\n      a test run by passing it as the :seed option to quick-check\n\n      :time-elapsed-ms\n      The total time, in milliseconds, of a successful test run\n\n      :fail\n      The generated values for the first failure; note that this is\n      always a vector, since prop/for-all can have multiple clauses\n\n      :failed-after-ms\n      The total time, in milliseconds, spent finding the first failing\n      trial\n\n      :failing-size\n      The value of the size parameter used to generate the first\n      failure\n\n      :result-data\n      The result data, if any, of the first failing trial (to take\n      advantage of this a property must return an object satisfying\n      the clojure.test.check.results/Result protocol)\n\n      :shrunk\n      A map of data about the shrinking process; nested keys that\n      appear at the top level have the same meaning; other keys are\n      documented next\n\n      :shrunk / :depth\n      The depth in the shrink tree that the smallest failing instance\n      was found; this is essentially the idea of how many times the\n      original failure was successfully shrunk\n\n      :smallest\n      The smallest values found in the shrinking process that still\n      fail the test; this is a vector of the same type as :fail\n\n      :time-shrinking-ms\n      The total time, in milliseconds, spent shrinking\n\n      :total-nodes-visited\n      The total number of steps in the shrinking process\n\n  Examples:\n\n      (def p (for-all [a gen/nat] (> (* a a) a)))\n\n      (quick-check 100 p)\n      (quick-check 200 p\n                   :seed 42\n                   :max-size 50\n                   :reporter-fn (fn [m]\n                                  (when (= :failure (:type m))\n                                    (println \"Uh oh...\"))))","~:top-fn",["^ ","^Y",true,"~:fixed-arity",2,"^10",2,"^V",[["^P",["^1H","^13",["^ ","^1I",["^17","^1J","^S"],"^1K",["^ ","^1J",200,"^S",["^P",["^1L",null]]]]]]],"^O",["^P",[["^1H","^13","~$&",["^ ","^1I",["^17","^1J","^S"],"^1K",["^ ","^1J",200,"^S",["^P",["^1L",null]]]]]]],"^X",["^P",[null]]]],"^5","~$clojure.test.check/quick-check","^I","target/public/cljs-out/dep/clojure/test/check.cljc","^M",18,"^1M",["^ ","^Y",true,"^1N",2,"^10",2,"^V",[["^P",["^1H","^13",["^ ","^1I",["^17","^1J","^S"],"^1K",["^ ","^1J",200,"^S",["^P",["^1L",null]]]]]]],"^O",["^P",[["^1H","^13","~$&",["^ ","^1I",["^17","^1J","^S"],"^1K",["^ ","^1J",200,"^S",["^P",["^1L",null]]]]]]],"^X",["^P",[null]]],"^V",[["^P",["^1H","^13",["^ ","^1I",["^17","^1J","^S"],"^1K",["^ ","^1J",200,"^S",["^P",["^1L",null]]]]]]],"^W",null,"^1N",2,"^X",["^P",[null]],"^K",1,"^Y",true,"~:methods",[["^ ","^1N",2,"^Y",true,"~:tag",["^4",["^1;","^["]]]],"^J",59,"^Z","^1;","^L",59,"^10",2,"^11",true,"^O",["^P",[["^1H","^13","~$&",["^ ","^1I",["^17","^1J","^S"],"^1K",["^ ","^1J",200,"^S",["^P",["^1L",null]]]]]]],"^T","Tests `property` `num-tests` times.\n\n  Takes several optional keys:\n\n  `:seed`\n    Can be used to re-run previous tests, as the seed used is returned\n    after a test is run.\n\n  `:max-size`.\n    can be used to control the 'size' of generated values. The size will\n    start at 0, and grow up to max-size, as the number of tests increases.\n    Generators will use the size parameter to bound their growth. This\n    prevents, for example, generating a five-thousand element vector on\n    the very first test.\n\n  `:reporter-fn`\n    A callback function that will be called at various points in the test\n    run, with a map like:\n\n      ;; called after a passing trial\n      {:type            :trial\n       :args            [...]\n       :num-tests       <number of tests run so far>\n       :num-tests-total <total number of tests to be run>\n       :seed            42\n       :pass?           true\n       :property        #<...>\n       :result          true\n       :result-data     {...}}\n\n      ;; called after the first failing trial\n      {:type         :failure\n       :fail         [...failing args...]\n       :failing-size 13\n       :num-tests    <tests ran before failure found>\n       :pass?        false\n       :property     #<...>\n       :result       false/exception\n       :result-data  {...}\n       :seed         42}\n\n    It will also be called on :complete, :shrink-step and :shrunk. Many\n    of the keys also appear in the quick-check return value, and are\n    documented below.\n\n  If the test passes, the return value will be something like:\n\n      {:num-tests       100,\n       :pass?           true,\n       :result          true,\n       :seed            1561826505982,\n       :time-elapsed-ms 24}\n\n  If the test fails, the return value will be something like:\n\n      {:fail            [0],\n       :failed-after-ms 0,\n       :failing-size    0,\n       :num-tests       1,\n       :pass?           false,\n       :result          false,\n       :result-data     nil,\n       :seed            1561826506080,\n       :shrunk\n       {:depth               0,\n        :pass?               false,\n        :result              false,\n        :result-data         nil,\n        :smallest            [0],\n        :time-shrinking-ms   0,\n        :total-nodes-visited 0}}\n\n  The meaning of the individual entries is:\n\n      :num-tests\n      The total number of trials that was were run, not including\n      shrinking (if applicable)\n\n      :pass?\n      A boolean indicating whether the test passed or failed\n\n      :result\n      A legacy entry that is similar to :pass?\n\n      :seed\n      The seed used for the entire test run; can be used to reproduce\n      a test run by passing it as the :seed option to quick-check\n\n      :time-elapsed-ms\n      The total time, in milliseconds, of a successful test run\n\n      :fail\n      The generated values for the first failure; note that this is\n      always a vector, since prop/for-all can have multiple clauses\n\n      :failed-after-ms\n      The total time, in milliseconds, spent finding the first failing\n      trial\n\n      :failing-size\n      The value of the size parameter used to generate the first\n      failure\n\n      :result-data\n      The result data, if any, of the first failing trial (to take\n      advantage of this a property must return an object satisfying\n      the clojure.test.check.results/Result protocol)\n\n      :shrunk\n      A map of data about the shrinking process; nested keys that\n      appear at the top level have the same meaning; other keys are\n      documented next\n\n      :shrunk / :depth\n      The depth in the shrink tree that the smallest failing instance\n      was found; this is essentially the idea of how many times the\n      original failure was successfully shrunk\n\n      :smallest\n      The smallest values found in the shrinking process that still\n      fail the test; this is a vector of the same type as :fail\n\n      :time-shrinking-ms\n      The total time, in milliseconds, spent shrinking\n\n      :total-nodes-visited\n      The total number of steps in the shrinking process\n\n  Examples:\n\n      (def p (for-all [a gen/nat] (> (* a a) a)))\n\n      (quick-check 100 p)\n      (quick-check 200 p\n                   :seed 42\n                   :max-size 50\n                   :reporter-fn (fn [m]\n                                  (when (= :failure (:type m))\n                                    (println \"Uh oh...\"))))"],"~$smallest-shrink",["^ ","^G",null,"^H",["^ ","^I","/Users/jb/Google-Drive/Planung/Clojure-Script/dep-reframe/target/public/cljs-out/dep/clojure/test/check.cljc","^J",231,"^K",8,"^L",231,"^M",23,"^N",true,"^O",["^P",["^Q",["^P",[["~$total-nodes-visited","~$depth","~$smallest","^18"]]]]]],"^N",true,"^5","~$clojure.test.check/smallest-shrink","^I","target/public/cljs-out/dep/clojure/test/check.cljc","^M",23,"^V",["^P",[["^1S","^1T","^1U","^18"]]],"^W",null,"^X",["^P",[null,null]],"^K",1,"^Y",false,"^J",231,"^Z","^[","^L",231,"^10",4,"^11",true,"^O",["^P",["^Q",["^P",[["^1S","^1T","^1U","^18"]]]]]]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ ","^?","^>","^>","^>"],"~:cljs.analyzer/constants",["^ ","~:seen",["^4",["~:args","~:clojure.test.check.properties/error","~:shrunk","~:failed-after-ms","~:total-nodes-visited","~:num-tests-total","~:failure","~:property","~:shrink-step","~:num-tests","~:type","~:max-size","~:seed","~:fail","~:result","~:result-data","~:smallest","~:trial","~:time-shrinking-ms","~:failing-size","~:reporter-fn","~:pass?","~:depth","~:complete","~:shrinking","~:time-elapsed-ms"]],"~:order",["^29","^26","^2=","^2D","^28","^2H","^2;","^2F","^20","^2:","^2C","^1[","^24","^2>","^2@","^23","^2E","^2A","^2?","^2G","^27","^22","^2<","^2B","^25","^21"]],"^T",null]